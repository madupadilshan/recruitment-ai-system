import os
import logging
import json
import fitz  # PyMuPDF
import google.generativeai as genai
from flask import Flask, request, jsonify
from flask_cors import CORS
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize Flask App
app = Flask(__name__)
CORS(app)

# Configure Gemini API
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
if not GEMINI_API_KEY:
    logger.warning("âš ï¸ GEMINI_API_KEY not found in environment variables. AI features will fail.")
else:
    genai.configure(api_key=GEMINI_API_KEY)
    logger.info("âœ… Gemini API conf

    for model_name in models:
        try:
            logger.info(f"ðŸ¤– Trying AI model: {model_name}")
            model = genai.GenerativeModel(model_name)
            response = model.generate_content(prompt)
            logger.info(f"âœ… Successfully used model: {model_name}")
            return response
        except Exception as e:
            logger.warning(f"âš ï¸ Model {model_name} failed: {str(e)[:100]}")
            last_error = e
            continue

    # If all models fail, raise the last error
    logger.error(f"âŒ All AI models failed. Last error: {last_error}")
    raise last_error

import gc

def extract_text_from_pdf(file_path):
    """Extracts text from a PDF file safely."""
    try:
        if not os.path.exists(file_path):
            logger.error(f"File not found: {file_path}")
            # Debug: List directory contents to help troubleshoot
            dir_path = os.path.dirname(file_path)
            if os.path.exists(dir_path):
                logger.info(f"Contents of {dir_path}: {os.listdir(dir_path)}")
            else:
                logger.error(f"Directory {dir_path} does not exist")
            return None

        doc = fitz.open(file_path)
        text = ""
        for page in doc:
            text += page.get_text() + "\n"
        doc.close()
        return text.strip()
    except Exception as e:
        logger.error(f"Error extracting PDF text: {e}")
        return None

@app.route('/', methods=['GET'])
def health_check():
    # Check if API key is configured
    api_configured = GEMINI_API_KEY is not None and len(GEMINI_API_KEY) > 10
    return jsonify({
        "status": "online",
        "service": "Recruitment AI Service",
        "version": "2.1.0",
        "gemini_configured": api_configured
    })

@app.route('/test-gemini', methods=['GET'])
def test_gemini():
    """Test endpoint to verify Gemini API is working."""
    try:
        if not GEMINI_API_KEY:
            return jsonify({"error": "GEMINI_API_KEY not configured"}), 500

        # Try to generate simple content
        response = generate_content_safe("Say 'Hello, Gemini is working!' in exactly 5 words.")
        return jsonify({
            "status": "success",
            "response": response.text[:100]
        })
    except Exception as e:
        logger.error(f"Gemini test failed: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/extract-text', methods=['POST'])
def extract_text_endpoint():
    """Endpoint to extract text from PDF."""
    try:
        data = request.get_json()
        file_path = data.get('file_path')

        if not file_path:
            return jsonify({"error": "No file path provided"}), 400

        text = extract_text_from_pdf(file_path)
        if text is None:
            return jsonify({"error": "Failed to extract text or file not found"}), 404

        return jsonify({"text": text})
    except Exception as e:
        logger.error(f"Extract text error: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/analyze-cv', methods=['POST'])
def analyze_cv():
    """
    Analyzes a CV against a Job Description using Gemini.
    Returns structured JSON matching the backend's expectation.
    """
    try:
        data = request.get_json()
        file_path = data.get('file_path')
        job_description = data.get('job_description', '')
        required_skills = data.get('required_skills', [])
        required_years = data.get('required_years', 0)

        logger.info(f"Analyzing CV: {file_path}")

        # 1. Get CV Text
        cv_text = data.get('cv_text')
        if not cv_text and file_path:
            cv_text = extract_text_from_pdf(file_path)

        if not cv_text:
            logger.error("Could not retrieve CV text")
            return jsonify({"error": "Could not retrieve CV text"}), 400

        # 2. Prepare Prompt
        prompt = f"""
        Act as an expert Technical Recruiter. Analyze the following CV against the Job Description.

        JOB DESCRIPTION:
        {job_description}

        REQUIRED SKILLS: {', '.join(required_skills) if required_skills else 'Not specified'}
        REQUIRED EXPERIENCE: {required_years} years

        CV TEXT:
        {cv_text[:15000]}

        Output a JSON object strictly following this schema:
        {{
            "overallScore": <number 0-100>,
            "skillsMatch": <number 0-100>,
            "experienceMatch": <number 0-100>,
            "extractedSkills": ["skill1", "skill2"],
            "matchingSkills": ["skill1", "skill2"],
            "missingSkills": ["skill1", "skill2"],
            "experienceYears": <number>,
            "recommendation": "Short summary recommendation",
            "aiSummary": {{
                "strengths": ["strength1", "strength2"],
                "weaknesses": ["weakness1", "weakness2"],
                "overallAssessment": "Detailed assessment",
                "recommendedActions": ["action1", "action2"],
                "fitScore": "Excellent Fit/Good Fit/Moderate Fit/Limited Fit",
                "experienceLevel": "Junior/Mid/Senior"
            }}
        }}
        """

        # 3. Call AI with Retry Logic
        response = generate_content_safe(prompt)

        # Force garbage collection
        gc.collect()

        # 4. Parse Response
        try:
            cleaned_response = response.text.replace('```json', '').replace('```', '').strip()
            result = json.loads(cleaned_response)
            return jsonify(result)
        except json.JSONDecodeError:
            logger.error("Failed to parse AI response JSON")
            return jsonify({"error": "AI response parsing failed", "raw": response.text}), 500

    except Exception as e:
        logger.error(f"Analyze CV Error: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/analyze-profile', methods=['POST'])
def analyze_profile():
    """Extracts structured profile data from CV text."""
    try:
        data = request.get_json()
        cv_text = data.get('cv_text', '')

        if not cv_text:
            return jsonify({"error": "No CV text provided"}), 400

        prompt = f"""
        Extract structured data from this CV.

        CV TEXT:
        {cv_text[:15000]}

        Return JSON:
        {{
            "personalInfo": {{ "name": "Candidate Name", "email": "", "phone": "", "location": "", "linkedIn": "" }},
            "professionalSummary": "Brief summary",
            "skills": ["skill1", "skill2"],
            "experience": {{
                "totalYears": <number>,
                "positions": [ {{ "title": "", "company": "", "duration": "", "description": "" }} ]
            }},
            "education": [ {{ "degree": "", "field": "", "institution": "", "year": "" }} ],
            "aiInsights": {{
                "experienceLevel": "",
                "domainExpertise": [],
                "keyStrengths": [],
                "recommendedRoles": []
            }}
        }}
        """

        response = generate_content_safe(prompt)
        cleaned_response = response.text.replace('```json', '').replace('```', '').strip()
        result = json.loads(cleaned_response)

        return jsonify({"status": "success", "data": result})

    except Exception as e:
        logger.error(f"Profile Analysis Error: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/ai-summary', methods=['POST'])
def ai_summary():
    """Generates a quick summary."""
    try:
        data = request.get_json()
        cv_text = data.get('cv_text', '')

        prompt = f"""
        Summarize this CV for a recruiter.
        CV TEXT: {cv_text[:10000]}

        Return JSON:
        {{
            "summary": "3-4 sentences",
            "key_skills": [],
            "experience_highlight": "",
            "suggested_roles": [],
            "rating": "8/10"
        }}
        """

        response = generate_content_safe(prompt)
        cleaned_response = response.text.replace('```json', '').replace('```', '').strip()
        result = json.loads(cleaned_response)

        return jsonify({"status": "success", "data": result})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/ai-chat', methods=['POST'])
def ai_chat():
    """Chat with the CV."""
    try:
        data = request.get_json()
        cv_text = data.get('cv_text', '')
        question = data.get('question', '')

        prompt = f"""
        Context: CV Content: {cv_text[:15000]}
        Question: {question}
        Answer as a helpful recruiter assistant based ONLY on the CV.
        """

        response = generate_content_safe(prompt)
        return jsonify({"status": "success", "answer": response.text})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/analyze-cv-comprehensive', methods=['POST'])
def analyze_cv_comprehensive():
    """
    Comprehensive CV analysis for candidates using Gemini AI.
    Analyzes skills, experience, achievements, and provides improvement suggestions.
    """
    try:
        data = request.get_json()
        file_path = data.get('file_path')
        cv_text = data.get('cv_text', '')

        logger.info(f"ðŸŽ¯ Comprehensive CV Analysis requested")

        # Get CV text from file if not provided directly
        if not cv_text and file_path:
            cv_text = extract_text_from_pdf(file_path)

        if not cv_text:
            logger.error("Could not retrieve CV text for comprehensive analysis")
            return jsonify({"error": "Could not retrieve CV text"}), 400

        logger.info(f"ðŸ“„ CV text length: {len(cv_text)}")

        # Comprehensive analysis prompt
        prompt = f"""
        You are an expert CV Analyst and Career Coach. Perform a comprehensive analysis of the following CV.

        CV TEXT:
        {cv_text[:15000]}

        Analyze the CV thoroughly and return a JSON object with the following structure:
        {{
            "personalInfo": {{
                "name": "Extracted name or 'Not Found'",
                "email": "Extracted email or 'Not Found'",
                "phone": "Extracted phone or 'Not Found'",
                "location": "Extracted location or 'Not Found'",
                "linkedIn": "Extracted LinkedIn URL or 'Not Found'"
            }},
            "professionalSummary": "A 2-3 sentence professional summary based on the CV",
            "skills": {{
                "technical": ["list of technical skills found"],
                "soft": ["list of soft skills found"],
                "tools": ["list of tools/software found"],
                "languages": ["programming or human languages found"]
            }},
            "experience": {{
                "totalYears": <IMPORTANT: First look for explicitly stated experience like "15+ years", "10 years of experience" etc. in the CV text. Use that number if found. Only calculate from positions if not explicitly mentioned>,
                "statedExperience": "The exact experience phrase found in CV like '15+ years of experience' or 'Not mentioned'",
                "level": "Junior/Mid-Level/Senior/Lead/Executive",
                "positions": [
                    {{
                        "title": "Job Title",
                        "company": "Company Name",
                        "duration": "Duration",
                        "highlights": ["key achievement 1", "key achievement 2"]
                    }}
                ]
            }},
            "education": [
                {{
                    "degree": "Degree name",
                    "field": "Field of study",
                    "institution": "Institution name",
                    "year": "Year or 'Not specified'"
                }}
            ],
            "achievements": {{
                "quantified": ["achievements with numbers/metrics"],
                "leadership": ["leadership achievements"],
                "technical": ["technical achievements"],
                "impactScore": <number 0-100 based on achievement quality>
            }},
            "cvQuality": {{
                "overallScore": <number 0-100>,
                "formatting": <number 0-100>,
                "completeness": <number 0-100>,
                "atsCompatibility": <number 0-100>,
                "strengths": ["list of CV strengths"],
                "improvements": ["list of areas to improve"],
                "criticalIssues": ["any critical issues found"]
            }},
            "careerInsights": {{
                "currentLevel": "Current career level assessment",
                "potentialRoles": ["suitable job roles"],
                "industryFit": ["industries this CV is suited for"],
                "salaryRange": "Estimated salary range based on experience",
                "growthAreas": ["skills/areas to develop for career growth"]
            }},
            "aiRecommendations": {{
                "immediateActions": ["things to fix immediately"],
                "shortTermGoals": ["goals for next 3-6 months"],
                "longTermGoals": ["goals for next 1-2 years"],
                "skillsToLearn": ["recommended skills to acquire"],
                "certifications": ["recommended certifications"]
            }}
        }}

        Be thorough but realistic in your assessment. Provide actionable feedback.
        """

        # Call AI
        response = generate_content_safe(prompt)

        # Force garbage collection
        gc.collect()

        # Parse Response
        try:
            cleaned_response = response.text.replace('```json', '').replace('```', '').strip()
            result = json.loads(cleaned_response)

            logger.info("âœ… Comprehensive CV analysis completed successfully")
            return jsonify({
                "status": "success",
                "data": result
            })
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse AI response JSON: {e}")
            # Return raw text if JSON parsing fails
            return jsonify({
                "status": "partial",
                "error": "AI response parsing failed",
                "raw": response.text[:2000]
            }), 500

    except Exception as e:
        logger.error(f"Comprehensive CV Analysis Error: {e}")
        return jsonify({"error": str(e)}), 500

# ðŸŽ¯ NEW: AI-Powered Job Matching Endpoint
@app.route('/match-jobs', methods=['POST'])
def match_jobs():
    """Use Gemini AI to intelligently match candidate profile with jobs."""
    try:
        data = request.get_json()
        candidate_profile = data.get('candidateProfile', {})
        jobs = data.get('jobs', [])

        if not candidate_profile or not jobs:
            return jsonify({"error": "Missing candidateProfile or jobs"}), 400

        logger.info(f"ðŸŽ¯ AI Job Matching: {len(jobs)} jobs for candidate")

        # Prepare candidate info for prompt
        candidate_skills = candidate_profile.get('skills', [])
        candidate_experience = candidate_profile.get('experience', {})
        candidate_tools = candidate_profile.get('tools', [])
        candidate_frameworks = candidate_profile.get('frameworks', [])
        candidate_summary = candidate_profile.get('profileSummary', '')

        # Combine all skills
        all_candidate_skills = list(set(
            candidate_skills +
            candidate_tools +
            candidate_frameworks
        ))

        # Prepare jobs info for prompt
        jobs_info = []
        for job in jobs[:20]:  # Limit to 20 jobs to avoid token limits
            jobs_info.append({
                "id": str(job.get('_id', '')),
                "title": job.get('title', ''),
                "description": job.get('description', '')[:500],
                "requiredSkills": job.get('requiredSkills', []),
                "requiredYears": job.get('requiredYears', 0)
            })

        prompt = f"""
        You are an expert AI recruitment matcher. Analyze the candidate profile and match with available jobs.

        CANDIDATE PROFILE:
        - Skills: {', '.join(all_candidate_skills[:30])}
        - Experience: {candidate_experience.get('totalYears', 0)} years
        - Experience Level: {candidate_experience.get('level', 'Not specified')}
        - Summary: {candidate_summary[:300]}

        AVAILABLE JOBS:
        {json.dumps(jobs_info, indent=2)}

        For each job, calculate a match score and identify matching skills.
        Consider these matching rules:
        1. "JavaScript" should match with "JS", "React", "Node.js", "TypeScript"
        2. "Python" should match with "Django", "Flask", "FastAPI", "Machine Learning"
        3. ".NET" should match with "C#", "ASP.NET", "VB.NET"
        4. "AWS" should match with "Cloud", "EC2", "S3", "Lambda"
        5. "SQL" should match with "MySQL", "PostgreSQL", "Oracle", "Database"
        6. Similar skills and related technologies should be matched intelligently

        Return a JSON array with this structure:
        [
            {{
                "jobId": "job_id_here",
                "matchScore": <number 0-100>,
                "matchingSkills": ["skill1", "skill2"],
                "missingSkills": ["skill1", "skill2"],
                "experienceMatch": true/false,
                "recommendation": "Short recommendation why this job is a good/bad match"
            }}
        ]

        Only include jobs with matchScore >= 40.
        Sort by matchScore descending.
        """

        response = generate_content_safe(prompt)
        gc.collect()

        try:
            cleaned_response = response.text.replace('```json', '').replace('```', '').strip()
            result = json.loads(cleaned_response)

            logger.info(f"âœ… AI matched {len(result)} jobs for candidate")
            return jsonify({
                "status": "success",
                "matchedJobs": result
            })
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse AI job matching response: {e}")
            return jsonify({
                "status": "error",
                "error": "AI response parsing failed",
                "raw": response.text[:1000]
            }), 500

    except Exception as e:
        logger.error(f"AI Job Matching Error: {e}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5001))
    app.run(host='0.0.0.0', port=port, debug=True)
